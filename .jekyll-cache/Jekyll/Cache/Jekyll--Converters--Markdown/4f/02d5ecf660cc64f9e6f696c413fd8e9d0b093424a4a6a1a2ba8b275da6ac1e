I"ï^<h1 id="c-notes">c++ Notes</h1>

<h2 id="1ç¼–è¯‘å™¨">1.ç¼–è¯‘å™¨</h2>
<ul>
  <li>msvc
    <ul>
      <li>windows</li>
      <li>æœ€å†å²æ‚ ä¹…ã€æœ€æˆç†Ÿï¼Œä½†ä¹Ÿæ˜¯æœ€æœ‰å†å²åŒ…è¢±çš„ç¼–è¯‘å™¨ï¼Œå¾®è½¯</li>
      <li>æ¨¡æ¿çš„æ”¯æŒåˆ™æ˜¯å®ƒçš„è½¯è‚‹</li>
      <li>2018 å¹´å®£å¸ƒå·²å…¨é¢æ”¯æŒ C++17 æ ‡å‡†</li>
    </ul>
  </li>
  <li>gcc
    <ul>
      <li>è·¨å¹³å°</li>
      <li>GCC çš„ç¬¬ä¸€ä¸ªç‰ˆæœ¬å‘å¸ƒäº 1987 å¹´ï¼Œæ˜¯ç”±è‡ªç”±è½¯ä»¶è¿åŠ¨çš„å‘èµ·äºº Richard Stallmanï¼ˆå¸¸å¸¸è¢«ç¼©å†™ä¸º RMSï¼‰äº²è‡ªå†™çš„</li>
      <li>ç”±äº GCC æ˜¯ç”¨ GPL å‘å¸ƒçš„ï¼Œä»»ä½•å¯¹ GCC çš„ä¿®æ”¹éƒ½å¿…é¡»ä»¥ GPL åè®®å‘å¸ƒ</li>
      <li>åº”ç”¨æœ€å¹¿çš„è‡ªç”±è½¯ä»¶ä¹‹ä¸€</li>
    </ul>
  </li>
  <li>clang
    <ul>
      <li>è·¨å¹³å°</li>
      <li>é”™è¯¯ä¿¡æ¯çš„å‹å¥½æ€§æ˜¯å®ƒçš„æœ€å¤§äº®ç‚¹</li>
      <li>æœ€æ–°ï¼Œ LLVMé¡¹ç›®çš„ä¸€éƒ¨åˆ†</li>
      <li>Clang ç›®å‰åœ¨ macOS ä¸‹æ˜¯é»˜è®¤çš„ C/C++ ç¼–è¯‘å™¨</li>
    </ul>
  </li>
</ul>

<h2 id="2å†…è”å‡½æ•°">2.å†…è”å‡½æ•°</h2>
<ul>
  <li>å¦‚æœä¸€äº›å‡½æ•°è¢«é¢‘ç¹è°ƒç”¨ï¼Œä¸æ–­åœ°æœ‰å‡½æ•°å…¥æ ˆï¼Œå³å‡½æ•°æ ˆï¼Œä¼šé€ æˆæ ˆç©ºé—´æˆ–æ ˆå†…å­˜çš„å¤§é‡æ¶ˆè€—</li>
  <li>å…³é”®å­—inline å¿…é¡»ä¸å‡½æ•°å®šä¹‰ä½“æ”¾åœ¨ä¸€èµ·æ‰èƒ½ä½¿å‡½æ•°æˆä¸ºå†…è”ï¼Œä»…å°†inline æ”¾åœ¨å‡½æ•°å£°æ˜å‰é¢ä¸èµ·ä»»ä½•ä½œç”¨</li>
  <li>inlineåªé€‚åˆæ¶µæ•°ä½“å†…ä»£ç ç®€å•çš„å‡½æ•°æ•°ä½¿ç”¨ï¼Œä¸èƒ½åŒ…å«å¤æ‚çš„ç»“æ„æ§åˆ¶è¯­å¥ä¾‹å¦‚whileã€switchï¼Œå¹¶ä¸”å†…è”å‡½æ•°æœ¬èº«ä¸èƒ½æ˜¯ç›´æ¥é€’å½’å‡½æ•°(è‡ªå·±å†…éƒ¨è¿˜è°ƒç”¨è‡ªå·±çš„å‡½æ•°)ã€‚</li>
  <li>å†…è”æ˜¯ä»¥ä»£ç è†¨èƒ€ï¼ˆå¤åˆ¶ï¼‰ä¸ºä»£ä»·ï¼Œä»…ä»…çœå»äº†å‡½æ•°è°ƒç”¨çš„å¼€é”€ï¼Œä»è€Œæé«˜å‡½æ•°çš„æ‰§è¡Œæ•ˆç‡</li>
  <li>æœ€å¥½å°†å†…è”å‡½æ•°å®šä¹‰æ”¾åœ¨å¤´æ–‡ä»¶ä¸­</li>
</ul>

<h2 id="3macro">3.macro</h2>
<ul>
  <li>#define é¢„å¤„ç†æŒ‡ä»¤ç”¨äºåˆ›å»ºç¬¦å·å¸¸é‡ï¼š#define PI 3.14159
    <ul>
      <li>#define æ¥å®šä¹‰ä¸€ä¸ªå¸¦æœ‰å‚æ•°çš„å®ï¼Œæ³¨æ„è¦å¤šåŠ æ‹¬å·ï¼šMIN(a,b) (a&lt;b ? a : b)</li>
    </ul>
  </li>
  <li>æ¡ä»¶ç¼–è¯‘ï¼š#ifdef #define #endif</li>
  <li>â€œ#â€ç½®äºidentifieré¢å‰è¡¨ç¤ºå°†identifierå˜æˆå­—ç¬¦ä¸²å­—é¢å€¼ï¼Œâ€œ##â€è¿æ¥</li>
</ul>

<h2 id="4array">4.array</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">//if you don't know how many elements you want, use a vector</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">parr</span><span class="p">[</span><span class="n">sz</span><span class="p">];</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ia1</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">a3</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="n">string</span> <span class="n">a4</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"hi"</span><span class="p">,</span> <span class="s">"bye"</span><span class="p">};</span> <span class="c1">// remember #include &lt;string&gt;</span>
<span class="n">string</span> <span class="n">Animals</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Elephant"</span><span class="p">,</span> <span class="s">"Fox"</span><span class="p">,</span> <span class="s">"Lion"</span><span class="p">,</span> <span class="s">"Tiger"</span><span class="p">};</span> <span class="c1">// remember #include &lt;string&gt;</span>
<span class="c1">//char array is special</span>
<span class="kt">char</span> <span class="n">a1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'C'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">};</span> <span class="c1">//list initialization, no null;</span>
<span class="n">CHECK_V</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">char</span> <span class="n">a22</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'C'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">};</span> <span class="c1">//list initialization, explicit null</span>
<span class="n">CHECK_V</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a22</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">char</span> <span class="n">a33</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"C++"</span><span class="p">;</span> <span class="c1">//null terminator added automatically</span>
<span class="n">CHECK_V</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a33</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">a44</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Daniel"</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="æ— æ³•é€šè¿‡å˜é‡æ¥å£°æ˜æ•°ç»„å¤§å°">æ— æ³•é€šè¿‡å˜é‡æ¥å£°æ˜æ•°ç»„å¤§å°</h3>
<p>ex:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">state</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>You can declare an array only with constant size, which can be deduced at compile time. 
variablesâ€™ values can be known only at runtime.</li>
  <li>To elaborate, when you allocate memory on the stack, the size must be known at compile time. 
Since the arrays are local to the method, they will be placed on the stack.</li>
</ul>

<h4 id="solution1">solution1:</h4>
<ul>
  <li>You can either use constant value, or allocate memory in the heap using new,
 and deallocate when done using delete, like</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>    <span class="kt">int</span><span class="o">*</span> <span class="n">zod1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">zo1</span><span class="p">];</span>
<span class="c1">//.... other code</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">zod1</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="solution2">solution2:</h4>
<ul>
  <li>use vector instead of array here also, and vector will take care of allocation on the heap.</li>
  <li>As a side note, you should not pass vector by value, as the whole vector will be copied 
and passed as argument, and no change will be visible at the caller side.
 Use vector<char>&amp; zodis1 instead.</char></li>
</ul>

<h2 id="5const">5.const</h2>

<h3 id="type-declaration-before-or-after-const-are-the-same">type declaration before or after const are the same</h3>

<blockquote>
  <p>tips: read from right to left</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="c1">//type declaration before or after const are the same</span>

<span class="c1">//tips: read from right to left</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="c1">//ptr is a pointer to constant int</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">;</span> <span class="c1">//prt1 is a pointer to an int who is constant</span>

<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">ptr3</span><span class="p">;</span> <span class="c1">//ptr3 is a const pointer to an int</span>

<span class="c1">//both ptr4 and ptr5 are constant pointer to a constant int</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="k">const</span> <span class="n">ptr4</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">ptr5</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="stl-iterators-are-modeled-on-pointers">stl iterators are modeled on pointers</h3>
<blockquote>
  <p>tips: read from left to right</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>    <span class="c1">//const pointer</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//ok</span>
    <span class="c1">//++iter; //error</span>

    <span class="c1">//pointer to const data</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">clter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="c1">//     *clter = 10; //error</span>
    <span class="o">++</span><span class="n">clter</span><span class="p">;</span>   <span class="c1">//ok</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="declaring-something-const-helps-compilers-detect-usage-errors">Declaring something const helps compilers detect usage errors.</h3>
<ul>
  <li>const can be applied to objects at any scope,
    <ul>
      <li>function parameters</li>
      <li>return types,</li>
      <li>member functions as a whole.</li>
    </ul>
  </li>
</ul>

<h2 id="6make-sure-that-objects-are-initialized-before-used">6.make sure that objects are initialized before used</h2>

<h3 id="initialized-is-not-guaranteed">initialized is not guaranteed</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//guaranteed to be initialized to zero</span>

<span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Point</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// p's data members are sometimes guaranteed sometimes are not</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<ul>
  <li>rules are complicated(not worth)
    <ul>
      <li>in the c part of c++ , initialization would incur a runtime cost, not guaranteed
        <ul>
          <li>array isnâ€™t guaranteed to be initialized</li>
        </ul>
      </li>
      <li>non-c parts of c++, might be guaranteed
        <ul>
          <li>a std::vector is guaranteed to be initialized</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="not-confuse-assignment-with-initialization">not confuse assignment with initialization</h3>
<ul>
  <li>assignment : inside the body of constructor</li>
  <li>initializatio took place earlier
    <ul>
      <li>default constructors were automatically called prior to entering the body</li>
      <li>but built-in type
        <ul>
          <li>no constuctor/destructor</li>
          <li>no guarantee it was initialized prior to its assignment</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The rules of C++ stipulate that data members of an object are initialized before the body of a constructor is entered</li>
</ul>

<blockquote>
  <p>use the member initialization list instead of assignments</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="c1">//ex.</span>
<span class="n">ABEntry</span><span class="o">::</span><span class="n">ABEntry</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">,</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;&amp;</span> <span class="n">phones</span><span class="p">)</span>
<span class="c1">//these are now all initializations</span>
<span class="o">:</span> <span class="n">theName</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="c1">// copy-constructed</span>
<span class="n">theAddress</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="c1">//  copy-constructed</span>
<span class="n">thePhones</span><span class="p">(</span><span class="n">phones</span><span class="p">),</span><span class="c1">//  copy-constructed</span>
<span class="n">numTimesConsulted</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{}</span> <span class="c1">// the ctor body is now empty</span>

<span class="c1">// use the member initialization list even when you want to default-construct a data member</span>
<span class="n">ABEntry</span><span class="o">::</span><span class="n">ABEntry</span><span class="p">()</span>
<span class="o">:</span> <span class="n">theName</span><span class="p">(),</span> <span class="c1">// call theNameâ€™s default ctor;</span>
<span class="n">theAddress</span><span class="p">(),</span> <span class="c1">// do the same for theAddress;</span>
<span class="n">thePhones</span><span class="p">(),</span> <span class="c1">// and for thePhones;</span>
<span class="n">numTimesConsulted</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// but explicitly initialize</span>
<span class="p">{}</span> <span class="c1">// numTimesConsulted to zero</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>more efficient
    <ul>
      <li>assigiment first called default constructors then assigned new value
        <ul>
          <li>all the deafult constructorsâ€™ work are wasted</li>
        </ul>
      </li>
      <li>member initialization list avoids it
        <ul>
          <li>arguments in the initialization list are used as constructor arguments for the various data members
            <ul>
              <li>For most types, a single call to a copy constructor is more efficient â€” sometimes much more efficient â€” than a call to the default constructor followed by a call to the copy assignment operator</li>
              <li>for  built-it types, no different between initialization and assignment
                <ul>
                  <li>for consistency, use member initialization too.</li>
                </ul>
              </li>
              <li>Sometimes the initialization list must be used,, even for built-in types.
                <ul>
                  <li>For example, data members that are const or are references must be initialized; they canâ€™t be assigned</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>if too much data members
        <ul>
          <li>multiple initialization lists introduces undesirable repetition (in the lists) and boredom</li>
          <li>moving the assignments to a single (typically private) function that all the constructors call</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="order-of-data-initialization">order of data initialization</h3>
<ul>
  <li>base classes are initialized before derived classes</li>
  <li>and within a class,data members are initialized in the order in which they are declared
    <ul>
      <li>even if they are listed in a different order on the member initialization list</li>
      <li>to avoid confusion: list members in the initialization list in the same order as theyâ€™re declared in the class</li>
    </ul>
  </li>
</ul>

<h3 id="staitc-object">staitc object</h3>
<ul>
  <li>A static object is one that exists from the time itâ€™s constructed until the end of the program.
    <ul>
      <li>excluded:Stack and heap-based objects</li>
      <li>Included are
        <ul>
          <li>global objects,</li>
          <li>objects defined at namespace scope,</li>
          <li>objects declared static inside classes,</li>
          <li>objects declared static inside functions,</li>
          <li>objects declared static at file scope</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="problem">problem</h4>
<ul>
  <li>the relative order of initialization of nonlocal static objects defined in different translation units is undefined</li>
  <li>itâ€™s not only impossible to determine the right order of initialization,</li>
  <li>itâ€™s typically not even worth looking for special cases where it is possible to determine the right order.</li>
</ul>

<h4 id="solution-replaced-non-local-static-objects-with-local-static-objects">solution: replaced non-local static objects with local static objects.</h4>
<ul>
  <li>move each non-local static object into its own function, where itâ€™s declared static
    <ul>
      <li>Singleton pattern</li>
    </ul>
  </li>
  <li>This approach is founded on C++â€™s guarantee that local static objects are initialized when the objectâ€™s definition is first encountered during a call to that function.</li>
  <li>As a bonus, if you never call a function emulating a non-local static object, you never incur the cost of constructing and destructing the object,
    <ul>
      <li>something that canâ€™t be said for true non-local static objects</li>
    </ul>
  </li>
  <li>might cause multi-theads problem
    <ul>
      <li>one solution is to manually invoke all the reference-returning functions during the single-threaded startup portion of the program.</li>
    </ul>
  </li>
</ul>

<h2 id="7c--size-of-int-long-short">7.C++ , size of int, long, short</h2>

<h3 id="decided-by-compiler">decided by compiler</h3>
<ul>
  <li>depends on the compiler and only on the compiler.</li>
  <li>Hardware/OS is of no importance at all</li>
  <li>The compiler is free to implement a hardware abstraction layer of any thickness and emulate absolutely anything</li>
</ul>

<h3 id="char--byte-octet">char , byte, octet</h3>
<ul>
  <li>char is always a byte , but itâ€™s not always an octet
    <ul>
      <li>byte
        <ul>
          <li>A byte is the smallest addressable unit of memory (in most definitions),</li>
        </ul>
      </li>
      <li>octet
        <ul>
          <li>an octet is 8-bit unit of memory</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sizeof(char) is always 1 for all implementations</li>
  <li>CHAR_BIT macro in limits.h
    <ul>
      <li>defines the size of a byte for a platform</li>
      <li>it is not always 8 bit.
        <ul>
          <li>16-bit, 32-bit bytes</li>
          <li>others[ex. 7], have to deal with aligned and padding</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="size">size</h3>
<ul>
  <li>range
    <ul>
      <li>signed char: -127 to 127 (note, not -128 to 127; this accommodates 1â€™s-complement and sign-and-magnitude platforms)</li>
      <li>unsigned char: 0 to 255</li>
      <li>â€œplainâ€ char: same range as signed char or unsigned char, implementation-defined</li>
      <li>signed short: -32767 to 32767</li>
      <li>unsigned short: 0 to 65535</li>
      <li>signed int: -32767 to 32767</li>
      <li>unsigned int: 0 to 65535</li>
      <li>signed long: -2147483647 to 2147483647</li>
      <li>unsigned long: 0 to 4294967295</li>
      <li>signed long long: -9223372036854775807 to 9223372036854775807</li>
      <li>unsigned long long: 0 to 18446744073709551615</li>
    </ul>
  </li>
  <li>rules
    <ul>
      <li>char, signed char, and unsigned char are at least 8 bits</li>
      <li>signed short, unsigned short, signed int, and unsigned int are at least 16 bits</li>
      <li>signed long and unsigned long are at least 32 bits</li>
      <li>signed long long and unsigned long long are at least 64 bits</li>
    </ul>
  </li>
</ul>

<h3 id="ref">ref</h3>
<p><a href="https://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c/437640#437640"></a>
<a href="https://stackoverflow.com/questions/589575/what-does-the-c-standard-state-the-size-of-int-long-type-to-be"></a>
<a href="https://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c/437640#437640"></a></p>
:ET